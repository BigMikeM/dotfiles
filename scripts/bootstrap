#!/bin/bash
# -*- mode: sh -*-

# Dotfiles and bootstrap installer
# Enhanced with better error handling, CLI options, and progress tracking

# Configuration
SKIP_CONFIRMATION=false
SKIP_GO=false
SKIP_NVM=false
SKIP_RUST=false
SKIP_NEOVIM=false
SKIP_ASTRONVIM=false
SKIP_GITUI=false
DRY_RUN=false
VERBOSE=false
AUTO_YES=false

# Progress tracking
declare -a COMPLETED_TASKS=()
declare -a FAILED_TASKS=()

# Set directory
export DOTFILES="$HOME/.dotfiles"
export SCRIPTS="$DOTFILES/scripts/"

# Error handling
on_error() {
	local exit_code=$?
	error "Script failed with exit code: $exit_code"
	error "Last command: $BASH_COMMAND"
	show_summary
	exit "$exit_code"
}

set -euo pipefail
trap on_error ERR SIGTERM SIGINT

# Imports
source "${SCRIPTS}/utils"
source "${SCRIPTS}/package_list"

PACKAGE_MANAGER="$(find_package_manager)"

usage() {
	cat <<EOF
Usage: $0 [OPTIONS]

OPTIONS:
    -h, --help          Show this help message
    -y, --yes           Skip all confirmation prompts (auto-yes)
    -d, --dry-run       Show what would be installed without executing
    -v, --verbose       Enable verbose output
    --skip-go           Skip Go installation
    --skip-nvm          Skip NVM/Node.js installation (also skips npm packages)
    --skip-rust         Skip Rust installation
    --skip-neovim       Skip Neovim installation
    --skip-astronvim    Skip AstroNvim installation
    --skip-gitui        Skip GitUI installation
    --dotfiles-path     Specify dotfiles path (default: $HOME/.dotfiles)

Examples:
    $0                  # Interactive installation
    $0 --yes            # Auto-install everything
    $0 --dry-run        # Show what would be installed
    $0 --skip-go --skip-gitui  # Skip specific components

Note: npm packages are installed via nvm-managed Node.js. If you skip NVM
installation, npm packages will also be skipped.
EOF
}

# Parse command line arguments
while [[ $# -gt 0 ]]; do
	case $1 in
	-h | --help)
		usage
		exit 0
		;;
	-y | --yes)
		AUTO_YES=true
		shift
		;;
	-d | --dry-run)
		DRY_RUN=true
		shift
		;;
	-v | --verbose)
		VERBOSE=true
		shift
		;;
	--skip-go)
		SKIP_GO=true
		shift
		;;
	--skip-nvm)
		SKIP_NVM=true
		shift
		;;
	--skip-rust)
		SKIP_RUST=true
		shift
		;;
	--skip-neovim)
		SKIP_NEOVIM=true
		shift
		;;
	--skip-astronvim)
		SKIP_ASTRONVIM=true
		shift
		;;
	--skip-gitui)
		SKIP_GITUI=true
		shift
		;;
	--dotfiles-path)
		DOTFILES="$2"
		SCRIPTS="$DOTFILES/scripts/"
		shift 2
		;;
	*)
		error "Unknown option: $1"
		usage
		exit 1
		;;
	esac
done

run_command() {
	local cmd="$*"
	if [[ "$VERBOSE" == true ]]; then
		info "Running: $cmd"
	fi

	if [[ "$DRY_RUN" == true ]]; then
		info "[DRY RUN] Would execute: $cmd"
		return 0
	fi

	eval "$cmd"
}

track_task() {
	local task_name="$1"
	local task_function="$2"

	info "Starting: $task_name"

	if "$task_function"; then
		COMPLETED_TASKS+=("$task_name")
		success "✓ $task_name completed"
	else
		FAILED_TASKS+=("$task_name")
		error "✗ $task_name failed"
	fi
	echo
}

show_summary() {
	echo
	info "=============== BOOTSTRAP SUMMARY ==============="

	if [[ ${#COMPLETED_TASKS[@]} -gt 0 ]]; then
		success "Completed tasks:"
		printf '  ✓ %s\n' "${COMPLETED_TASKS[@]}"
	fi

	if [[ ${#FAILED_TASKS[@]} -gt 0 ]]; then
		error "Failed tasks:"
		printf '  ✗ %s\n' "${FAILED_TASKS[@]}"
	fi

	info "================================================"
}

confirm_action() {
	local message="$1"
	local default="${2:-n}"

	if [[ "$AUTO_YES" == true ]]; then
		info "$message [AUTO-YES]"
		return 0
	fi

	if [[ "$DRY_RUN" == true ]]; then
		info "[DRY RUN] Would ask: $message"
		return 0
	fi

	local prompt="$message [y/N]: "
	if [[ "$default" == "y" ]]; then
		prompt="$message [Y/n]: "
	fi

	read -rp "$prompt" -n 1 answer
	echo

	if [[ "$default" == "y" ]]; then
		[[ "${answer,,}" != "n" ]]
	else
		[[ "${answer,,}" == "y" ]]
	fi
}

on_start() {
	info "     |-|                                             |-|     "
	info "     |-|         Custom dotfiles bootstrap.          |-|     "
	info "     |-|                                             |-|     "
	info "     |-|     This script will attempt to install     |-|     "
	info "     |-|      and set up a curated selection of      |-|     "
	info "     |-|        GUI and CLI apps, as well as         |-|     "
	info "     |-|         custom configuration files.         |-|     "
	info "     |-|                                             |-|     "
	info "     |-|          created by @denysdovhan            |-|     "
	info "     |-|            forked by @BigMikeM              |-|     "
	info "     |-|                                             |-|     "

	if [[ "$DRY_RUN" == true ]]; then
		info "     |-|              DRY RUN MODE                |-|     "
	fi

	echo

	if ! confirm_action "Would you like to proceed with installation?" "n"; then
		info "Exiting Script."
		exit 0
	fi

	if [[ "$DRY_RUN" == false ]]; then
		echo "Please enter your password to get started:"
		sudo -v

		# Keep sudo alive
		while true; do
			sudo -n true
			sleep 60
			kill -0 "$$" || exit
		done 2>/dev/null &
	fi
}

install_go() {
	if _exists go; then
		info "Go is already installed."
		return 0
	fi

	if [[ "$SKIP_GO" == true ]]; then
		info "Skipping Go installation (--skip-go flag)."
		return 0
	fi

	if ! confirm_action "Would you like to install Go?"; then
		info "Skipping Go installation."
		return 0
	fi

	info "Installing Go."

	# Fetch the latest version of Go from the official website
	local latest_version
	if [[ "$DRY_RUN" == false ]]; then
		latest_version=$(curl -s 'https://go.dev/VERSION?m=text' | head -1) ||
			on_error "Couldn't fetch the latest version of Go."
	else
		latest_version="go1.23.0" # Example for dry run
	fi

	# Download the latest version
	run_command "curl -LO 'https://go.dev/dl/${latest_version}.linux-amd64.tar.gz'"

	# Unpack the tarball
	run_command "sudo tar -C /usr/local -xzf '${latest_version}.linux-amd64.tar.gz'"

	# Remove the downloaded tarball
	run_command "rm '${latest_version}.linux-amd64.tar.gz'"

	return 0
}

install_gitui() {
	if _exists gitui; then
		info "GitUI is already installed."
		return 0
	fi

	if [[ "$SKIP_GITUI" == true ]]; then
		info "Skipping GitUI installation (--skip-gitui flag)."
		return 0
	fi

	if ! confirm_action "Would you like to install GitUI?"; then
		info "Skipping GitUI installation."
		return 0
	fi

	info "GitUI will be installed via system package manager."
	info "Make sure 'gitui' is included in your package lists."

	return 0
}

install_nvm() {
	if _exists nvm; then
		info "NVM is already installed."
		return 0
	fi

	if [[ "$SKIP_NVM" == true ]]; then
		info "Skipping NVM installation (--skip-nvm flag)."
		return 0
	fi

	if ! confirm_action "Would you like to install Node Version Manager (NVM)?"; then
		info "Skipping NVM installation."
		return 0
	fi

	info "Installing Node Version Manager."
	run_command "export PROFILE=/dev/null; curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.7/install.sh | bash"

	if [[ "$DRY_RUN" == false ]]; then
		# Source the nvm script to make nvm available in the current shell session
		export NVM_DIR="$HOME/.nvm"
		[ -s "$NVM_DIR/nvm.sh" ] && \. "$NVM_DIR/nvm.sh"

		info "Installing Node LTS."
		run_command "nvm install --lts"
		run_command "nvm use --lts"
		run_command "nvm alias default lts/*"

		if confirm_action "Would you also like to install the latest version of Node?"; then
			run_command "nvm install node"
		fi
	else
		info "[DRY RUN] Would install Node LTS and optionally latest Node"
	fi

	return 0
}

install_rustup() {
	if _exists rustup; then
		info "Rustup is already installed."
		return 0
	fi

	if [[ "$SKIP_RUST" == true ]]; then
		info "Skipping Rust installation (--skip-rust flag)."
		return 0
	fi

	if ! confirm_action "Would you like to install Rust?"; then
		info "Skipping Rust installation."
		return 0
	fi

	info "Installing Rustup"
	if _exists paru; then
		run_command "paru -S rustup"
	else
		run_command "curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh -s -- -y"

		if [[ "$DRY_RUN" == false ]]; then
			info "Installing latest stable version of Rust and Cargo."
			source "$HOME/.cargo/env"
		fi
	fi

	run_command "rustup default stable"
	return 0
}

cargo_install() {
	info "Installing extras with Cargo."
	if [[ "$DRY_RUN" == false ]]; then
		run_command "cargo install ${cargo_packages[*]}"
		run_command "sheldon lock --update"
	else
		info "[DRY RUN] Would install: ${cargo_packages[*]}"
		info "[DRY RUN] Would run: sheldon lock --update"
	fi
	return 0
}

# New function to install npm packages via nvm
npm_install() {
	# Check if we should skip npm installation
	if [[ "$SKIP_NVM" == true ]]; then
		info "Skipping NPM packages installation (NVM was skipped)."
		return 0
	fi

	# Check if npm is available (either via nvm or system)
	if ! _exists npm; then
		warn "npm not found. Make sure Node.js is installed via nvm."
		return 1
	fi

	if [[ ${#npm_packages[@]} -eq 0 ]]; then
		info "No npm packages to install."
		return 0
	fi

	if ! confirm_action "Would you like to install npm packages globally?"; then
		info "Skipping npm packages installation."
		return 0
	fi

	info "Installing npm packages globally via nvm-managed Node.js."

	# Ensure we're using the nvm environment
	if [[ "$DRY_RUN" == false ]] && [[ -s "$HOME/.nvm/nvm.sh" ]]; then
		source "$HOME/.nvm/nvm.sh"
		# Use the default version
		nvm use default 2>/dev/null || nvm use node 2>/dev/null || nvm use lts/* 2>/dev/null
	fi

	# Show current node/npm versions
	if [[ "$DRY_RUN" == false ]]; then
		info "Using Node.js: $(node --version 2>/dev/null || echo 'not found')"
		info "Using npm: $(npm --version 2>/dev/null || echo 'not found')"
		info "npm prefix: $(npm config get prefix 2>/dev/null || echo 'not found')"
	fi

	# Install packages one by one for better error handling
	local failed_packages=()
	for package in "${npm_packages[@]}"; do
		if [[ "$DRY_RUN" == true ]]; then
			info "[DRY RUN] Would install: npm install -g $package"
		else
			info "Installing: $package"
			if ! run_command "npm install -g '$package'"; then
				warn "Failed to install npm package: $package"
				failed_packages+=("$package")
			fi
		fi
	done

	# Report any failures
	if [[ ${#failed_packages[@]} -gt 0 ]]; then
		warn "Failed to install the following npm packages:"
		printf '  - %s\n' "${failed_packages[@]}"
		return 1
	fi

	success "All npm packages installed successfully."
	return 0
}

# New function to install Python packages
pip_install() {
	if [[ ${#pip_packages[@]} -eq 0 ]]; then
		info "No pip packages to install."
		return 0
	fi

	if ! _exists pip3 && ! _exists pip; then
		warn "pip not found. Make sure Python is installed."
		return 1
	fi

	if ! confirm_action "Would you like to install Python packages?"; then
		info "Skipping pip packages installation."
		return 0
	fi

	info "Installing Python packages."

	# Use pip3 if available, fallback to pip
	local pip_cmd="pip3"
	if ! _exists pip3; then
		pip_cmd="pip"
	fi

	# Upgrade pip first
	run_command "$pip_cmd install --upgrade pip"

	# Install packages
	if [[ "$DRY_RUN" == true ]]; then
		info "[DRY RUN] Would install: $pip_cmd install --user ${pip_packages[*]}"
	else
		# Install to user directory to avoid system conflicts
		run_command "$pip_cmd install --user ${pip_packages[*]}"
	fi

	return 0
}

apt_install() {
	run_command "sudo apt update"
	run_command "sudo apt install -y ${apt_packages[*]}"
}

apt-wsl_install() {
	run_command "sudo apt update"
	run_command "sudo apt install -y ${wsl_packages[*]}"
}

rpm_install() {
	run_command "sudo dnf install --refresh -y ${rpm_packages[*]}"
	run_command "sudo dnf group install -y ${rpm_groups[*]}"
}

arch_install() {
	run_command "sudo pacman -Sy --needed --noconfirm ${arch_packages[*]}"
}

install_astronvim() {
	if [[ "$SKIP_ASTRONVIM" == true ]]; then
		info "Skipping AstroNvim installation (--skip-astronvim flag)."
		return 0
	fi

	if ! confirm_action "Would you like to install AstroNvim?"; then
		info "Skipping AstroNvim installation."
		return 0
	fi

	info "Starting the AstroNvim installer."

	# Back up existing Neovim configuration
	if [[ -d $HOME/.config/nvim ]]; then
		info "Backing up current NeoVim configuration to $HOME/.config/nvim.bak"
		run_command "mv '$HOME/.config/nvim' '$HOME/.config/nvim.bak'"
	fi

	# Clean existing NeoVim folders
	if [[ -d $HOME/.local/share/nvim ]]; then
		info "Backing up local NeoVim folders."
		run_command "mv '$HOME/.local/share/nvim' '$HOME/.local/share/nvim.bak'"
		run_command "mv '$HOME/.local/state/nvim' '$HOME/.local/state/nvim.bak'"
		run_command "mv '$HOME/.cache/nvim' '$HOME/.cache/nvim.bak'"
	fi

	run_command "git clone --depth 1 https://github.com/AstroNvim/template '$HOME/.config/nvim'"
	run_command "rm -rf '$HOME/.config/nvim/.git'"

	success "AstroNvim installed successfully."
	info "Please run NeoVim (nvim) after bootstrap finishes to complete the installation of AstroNvim."

	return 0
}

install_software() {
	info "Installing software with system package manager."
	"${PACKAGE_MANAGER}"_install
	return 0
}

install_neovim() {
	if [[ "$SKIP_NEOVIM" == true ]]; then
		info "Skipping Neovim installation (--skip-neovim flag)."
		return 0
	fi

	info "This script will attempt to install the latest stable version of Neovim using the appimage."
	info "This is only necessary if you need a recent version of NeoVim and your distro does not include it."

	if _exists nvim; then
		local nvim_version
		nvim_version="$(nvim -v | head -1 | cut -d"v" -f2)"
		info "Currently installed version of NeoVim: [$nvim_version]"
	else
		info "NeoVim does not appear to be installed."
	fi

	if ! confirm_action "Would you like to proceed with Neovim AppImage installation?"; then
		info "Skipping NeoVim Appimage installation."
		return 0
	fi

	local package_name="nvim-linux-x86_64.appimage"
	local download_link="https://github.com/neovim/neovim/releases/download/v0.11.3/$package_name"

	# Download the latest Neovim AppImage
	run_command "wget -O /tmp/nvim $download_link"

	# Make the downloaded file executable
	run_command "chmod +x /tmp/nvim"

	# Move the AppImage to /usr/local
	run_command "sudo mv /tmp/nvim /usr/local/bin/nvim"

	success "NeoVim AppImage installed successfully."
	return 0
}

set_zsh() {
	local shell
	if ! _exists zsh; then
		warn "ZSH not found! Other shells are not currently supported"
		return 1
	fi

	shell="$(_user_default_shell)"
	if [[ "${shell,,}" != "zsh" ]]; then
		info "Default shell will be changed to ZSH."

		if confirm_action "Are you sure you want to change the default shell to ZSH?" "y"; then
			run_command "chsh -s '$(which zsh)'"
		fi
	else
		info "ZSH is already the default shell."
	fi

	return 0
}

install_external_required() {
	if [[ "$SKIP_RUST" == false ]]; then
		track_task "Rust Installation" install_rustup
		track_task "Cargo Packages" cargo_install
	fi
}

install_external_optional() {
	if [[ "$SKIP_NEOVIM" == false ]]; then
		track_task "Neovim Installation" install_neovim
	fi
	if [[ "$SKIP_NVM" == false ]]; then
		track_task "NVM Installation" install_nvm
		# Install npm packages after nvm is set up
		track_task "NPM Packages" npm_install
	fi
	if [[ "$SKIP_GO" == false ]]; then
		track_task "Go Installation" install_go
	fi
	if [[ "$SKIP_GITUI" == false ]]; then
		track_task "GitUI Installation" install_gitui
	fi
	if [[ "$SKIP_ASTRONVIM" == false ]]; then
		track_task "AstroNvim Installation" install_astronvim
	fi

	# Install Python packages
	track_task "Python Packages" pip_install
}

install_external() {
	info "Installing external software."
	install_external_required
	install_external_optional
}

on_finish() {
	info "=============================================="
	info "Bootstrap installation completed!"
	info ""
	info "Next steps:"
	info "1. Restart your terminal or run 'source ~/.zshrc'"
	info "2. If NVM was installed, run 'node --version' to verify"
	info "3. If AstroNvim was installed, run 'nvim' to complete setup"
	info "4. Customize your configuration in ~/.zshlocal"
	info ""
	success "Happy coding! 🚀"
}

main() {
	on_start
	track_task "System Packages" install_software
	install_external
	track_task "Shell Setup" set_zsh
	show_summary
	on_finish
}

main "$@"

# vim: ft=sh
