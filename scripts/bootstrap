#!/bin/bash
# -*- mode: sh -*-

# Dotfiles and bootstrap installer
# Enhanced with better error handling, CLI options, and progress tracking

# Configuration
SKIP_CONFIRMATION=false
SKIP_GO=false
SKIP_FNM=false
SKIP_RUST=false
SKIP_NEOVIM=false
SKIP_ASTRONVIM=false
SKIP_GITUI=false
DRY_RUN=false
VERBOSE=false
AUTO_YES=false

# Progress tracking
declare -a COMPLETED_TASKS=()
declare -a FAILED_TASKS=()

# Set directory
export DOTFILES="$HOME/.dotfiles"
export SCRIPTS="$DOTFILES/scripts/"

# Error handling
on_error() {
	local exit_code=$?
	error "Script failed with exit code: $exit_code"
	error "Last command: $BASH_COMMAND"
	show_summary
	exit "$exit_code"
}

set -euo pipefail
trap on_error ERR SIGTERM SIGINT

# Imports
source "${SCRIPTS}/utils"
source "${SCRIPTS}/package_list"

PACKAGE_MANAGER="$(find_package_manager)"

usage() {
	cat <<EOF
Usage: $0 [OPTIONS]

OPTIONS:
    -h, --help          Show this help message
    -y, --yes           Skip all confirmation prompts (auto-yes)
    -d, --dry-run       Show what would be installed without executing
    -v, --verbose       Enable verbose output
    --skip-go           Skip Go installation
    --skip-fnm          Skip fnm/Node.js installation (also skips npm packages)
    --skip-rust         Skip Rust installation
    --skip-neovim       Skip Neovim installation
    --skip-astronvim    Skip AstroNvim installation
    --skip-gitui        Skip GitUI installation
    --dotfiles-path     Specify dotfiles path (default: $HOME/.dotfiles)

Examples:
    $0                  # Interactive installation
    $0 --yes            # Auto-install everything
    $0 --dry-run        # Show what would be installed
    $0 --skip-go --skip-gitui  # Skip specific components

Note: npm packages are installed via fnm-managed Node.js. If you skip fnm
installation, npm packages will also be skipped.
EOF
}

# Parse command line arguments
while [[ $# -gt 0 ]]; do
	case $1 in
	-h | --help)
		usage
		exit 0
		;;
	-y | --yes)
		AUTO_YES=true
		shift
		;;
	-d | --dry-run)
		DRY_RUN=true
		shift
		;;
	-v | --verbose)
		VERBOSE=true
		shift
		;;
	--skip-go)
		SKIP_GO=true
		shift
		;;
	--skip-fnm)
		SKIP_FNM=true
		shift
		;;
	--skip-rust)
		SKIP_RUST=true
		shift
		;;
	--skip-neovim)
		SKIP_NEOVIM=true
		shift
		;;
	--skip-astronvim)
		SKIP_ASTRONVIM=true
		shift
		;;
	--skip-gitui)
		SKIP_GITUI=true
		shift
		;;
	--dotfiles-path)
		DOTFILES="$2"
		SCRIPTS="$DOTFILES/scripts/"
		shift 2
		;;
	*)
		error "Unknown option: $1"
		usage
		exit 1
		;;
	esac
done

run_command() {
	local cmd="$*"
	if [[ "$VERBOSE" == true ]]; then
		info "Running: $cmd"
	fi

	if [[ "$DRY_RUN" == true ]]; then
		info "[DRY RUN] Would execute: $cmd"
		return 0
	fi

	eval "$cmd"
}

track_task() {
	local task_name="$1"
	local task_function="$2"

	info "Starting: $task_name"

	if "$task_function"; then
		COMPLETED_TASKS+=("$task_name")
		success "âœ“ $task_name completed"
	else
		FAILED_TASKS+=("$task_name")
		error "âœ— $task_name failed"
	fi
	echo
}

show_summary() {
	echo
	info "=============== BOOTSTRAP SUMMARY ==============="

	if [[ ${#COMPLETED_TASKS[@]} -gt 0 ]]; then
		success "Completed tasks:"
		printf '  âœ“ %s\n' "${COMPLETED_TASKS[@]}"
	fi

	if [[ ${#FAILED_TASKS[@]} -gt 0 ]]; then
		error "Failed tasks:"
		printf '  âœ— %s\n' "${FAILED_TASKS[@]}"
	fi

	info "================================================"
}

confirm_action() {
	local message="$1"
	local default="${2:-n}"

	if [[ "$AUTO_YES" == true ]]; then
		info "$message [AUTO-YES]"
		return 0
	fi

	if [[ "$DRY_RUN" == true ]]; then
		info "[DRY RUN] Would ask: $message"
		return 0
	fi

	local prompt="$message [y/N]: "
	if [[ "$default" == "y" ]]; then
		prompt="$message [Y/n]: "
	fi

	read -rp "$prompt" -n 1 answer
	echo

	if [[ "$default" == "y" ]]; then
		[[ "${answer,,}" != "n" ]]
	else
		[[ "${answer,,}" == "y" ]]
	fi
}

on_start() {
	info "     |-|                                             |-|     "
	info "     |-|         Custom dotfiles bootstrap.          |-|     "
	info "     |-|                                             |-|     "
	info "     |-|     This script will attempt to install     |-|     "
	info "     |-|      and set up a curated selection of      |-|     "
	info "     |-|        GUI and CLI apps, as well as         |-|     "
	info "     |-|         custom configuration files.         |-|     "
	info "     |-|                                             |-|     "
	info "     |-|          created by @denysdovhan            |-|     "
	info "     |-|            forked by @BigMikeM              |-|     "
	info "     |-|                                             |-|     "

	if [[ "$DRY_RUN" == true ]]; then
		info "     |-|              DRY RUN MODE                |-|     "
	fi

	echo

	if ! confirm_action "Would you like to proceed with installation?" "n"; then
		info "Exiting Script."
		exit 0
	fi

	if [[ "$DRY_RUN" == false ]]; then
		echo "Please enter your password to get started:"
		sudo -v

		# Keep sudo alive
		while true; do
			sudo -n true
			sleep 60
			kill -0 "$$" || exit
		done 2>/dev/null &
	fi
}

install_go() {
	if _exists go; then
		info "Go is already installed."
		return 0
	fi

	if [[ "$SKIP_GO" == true ]]; then
		info "Skipping Go installation (--skip-go flag)."
		return 0
	fi

	if ! confirm_action "Would you like to install Go?"; then
		info "Skipping Go installation."
		return 0
	fi

	info "Installing Go."

	# Fetch the latest version of Go from the official website
	local latest_version
	if [[ "$DRY_RUN" == false ]]; then
		latest_version=$(curl -s 'https://go.dev/VERSION?m=text' | head -1) ||
			on_error "Couldn't fetch the latest version of Go."
	else
		latest_version="go1.23.0" # Example for dry run
	fi

	# Download the latest version
	run_command "curl -LO 'https://go.dev/dl/${latest_version}.linux-amd64.tar.gz'"

	# Unpack the tarball
	run_command "sudo tar -C /usr/local -xzf '${latest_version}.linux-amd64.tar.gz'"

	# Remove the downloaded tarball
	run_command "rm '${latest_version}.linux-amd64.tar.gz'"

	return 0
}

install_gitui() {
	if _exists gitui; then
		info "GitUI is already installed."
		return 0
	fi

	if [[ "$SKIP_GITUI" == true ]]; then
		info "Skipping GitUI installation (--skip-gitui flag)."
		return 0
	fi

	if ! confirm_action "Would you like to install GitUI?"; then
		info "Skipping GitUI installation."
		return 0
	fi

	info "GitUI will be installed via system package manager."
	info "Make sure 'gitui' is included in your package lists."

	return 0
}

install_fnm() {
	if _exists fnm; then
		info "fnm is already installed."
		return 0
	fi

	if [[ "$SKIP_FNM" == true ]]; then
		info "Skipping fnm installation (--skip-fnm flag)."
		return 0
	fi

	if ! confirm_action "Would you like to install Fast Node Manager (fnm)?"; then
		info "Skipping fnm installation."
		return 0
	fi

	info "Installing Fast Node Manager (fnm)."
	run_command "curl -fsSL https://fnm.vercel.app/install | bash -s -- --skip-shell"

	if [[ "$DRY_RUN" == false ]]; then
		# Source fnm to make it available in the current shell session
		export PATH="$HOME/.local/share/fnm:$PATH"
		eval "$(fnm env --use-on-cd)"

		info "Installing Node LTS."
		run_command "fnm install --lts"
		run_command "fnm use lts-latest"
		run_command "fnm default lts-latest"

		if confirm_action "Would you also like to install the latest version of Node?"; then
			run_command "fnm install latest"
		fi
	else
		info "[DRY RUN] Would install Node LTS and optionally latest Node"
	fi

	return 0
}

install_rustup() {
	if _exists rustup; then
		info "Rustup is already installed."
		return 0
	fi

	if [[ "$SKIP_RUST" == true ]]; then
		info "Skipping Rust installation (--skip-rust flag)."
		return 0
	fi

	if ! confirm_action "Would you like to install Rust?"; then
		info "Skipping Rust installation."
		return 0
	fi

	info "Installing Rustup"
	if _exists paru; then
		run_command "paru -S rustup"
	else
		run_command "curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh -s -- -y"

		if [[ "$DRY_RUN" == false ]]; then
			info "Installing latest stable version of Rust and Cargo."
			# Source cargo env to make rustup/cargo available in current session
			if [[ -f "$HOME/.cargo/env" ]]; then
				source "$HOME/.cargo/env"
			fi
		fi
	fi

	# Ensure rustup is available before running default command
	if [[ "$DRY_RUN" == false ]]; then
		# Re-source cargo env if needed
		if ! _exists rustup && [[ -f "$HOME/.cargo/env" ]]; then
			source "$HOME/.cargo/env"
		fi
	fi

	run_command "rustup default stable"
	return 0
}

install_uv() {
	if _exists uv; then
		info "uv is already installed."
		return 0
	fi

	info "Installing uv (fast Python package manager)."
	run_command "curl -LsSf https://astral.sh/uv/install.sh | sh"

	if [[ "$DRY_RUN" == false ]]; then
		# Source uv env to make it available in the current shell session
		if [[ -f "$HOME/.local/bin/uv" ]]; then
			export PATH="$HOME/.local/bin:$PATH"
		elif [[ -f "$HOME/.cargo/bin/uv" ]]; then
			export PATH="$HOME/.cargo/bin:$PATH"
		fi
	fi

	return 0
}

cargo_install() {
	info "Installing extras with Cargo."
	if [[ "$DRY_RUN" == false ]]; then
		run_command "cargo install ${cargo_packages[*]}"
		run_command "sheldon lock --update"
	else
		info "[DRY RUN] Would install: ${cargo_packages[*]}"
		info "[DRY RUN] Would run: sheldon lock --update"
	fi
	return 0
}

# Install npm packages via fnm
npm_install() {
	# Check if we should skip npm installation
	if [[ "$SKIP_FNM" == true ]]; then
		info "Skipping NPM packages installation (fnm was skipped)."
		return 0
	fi

	# Check if npm is available (either via fnm or system)
	if ! _exists npm; then
		warn "npm not found. Make sure Node.js is installed via fnm."
		return 1
	fi

	if [[ ${#npm_packages[@]} -eq 0 ]]; then
		info "No npm packages to install."
		return 0
	fi

	if ! confirm_action "Would you like to install npm packages globally?"; then
		info "Skipping npm packages installation."
		return 0
	fi

	info "Installing npm packages globally via fnm-managed Node.js."

	# Ensure we're using the fnm environment
	if [[ "$DRY_RUN" == false ]] && _exists fnm; then
		export PATH="$HOME/.local/share/fnm:$PATH"
		eval "$(fnm env --use-on-cd)"
		# Use the default version
		fnm use default 2>/dev/null || fnm use lts-latest 2>/dev/null
	fi

	# Show current node/npm versions
	if [[ "$DRY_RUN" == false ]]; then
		info "Using Node.js: $(node --version 2>/dev/null || echo 'not found')"
		info "Using npm: $(npm --version 2>/dev/null || echo 'not found')"
		info "npm prefix: $(npm config get prefix 2>/dev/null || echo 'not found')"
	fi

	# Install packages one by one for better error handling
	local failed_packages=()
	for package in "${npm_packages[@]}"; do
		if [[ "$DRY_RUN" == true ]]; then
			info "[DRY RUN] Would install: npm install -g $package"
		else
			info "Installing: $package"
			if ! run_command "npm install -g '$package'"; then
				warn "Failed to install npm package: $package"
				failed_packages+=("$package")
			fi
		fi
	done

	# Report any failures
	if [[ ${#failed_packages[@]} -gt 0 ]]; then
		warn "Failed to install the following npm packages:"
		printf '  - %s\n' "${failed_packages[@]}"
		return 1
	fi

	success "All npm packages installed successfully."
	return 0
}

# Install Python CLI tools using uv tool install
uv_install() {
	if [[ ${#uv_tools[@]} -eq 0 ]]; then
		info "No Python CLI tools to install."
		return 0
	fi

	if ! confirm_action "Would you like to install Python CLI tools?"; then
		info "Skipping Python CLI tools installation."
		return 0
	fi

	# Ensure uv is installed first
	if ! _exists uv; then
		warn "uv not found. Installing uv first..."
		if ! install_uv; then
			error "Failed to install uv. Cannot install Python CLI tools."
			return 1
		fi
	fi

	info "Installing Python CLI tools with uv."
	info "Note: Python libraries (pandas, numpy, etc.) should be installed per-project with 'uv pip install'"

	# Install each tool with uv tool install
	local failed_tools=()
	for tool in "${uv_tools[@]}"; do
		if [[ "$DRY_RUN" == true ]]; then
			info "[DRY RUN] Would install: uv tool install $tool"
		else
			info "Installing $tool..."
			# Use --force for tools that might already exist (like ruff)
			if ! run_command "uv tool install --force $tool"; then
				warn "Failed to install $tool with uv, continuing..."
				failed_tools+=("$tool")
			fi
		fi
	done

	# Report any failures
	if [[ ${#failed_tools[@]} -gt 0 ]]; then
		warn "Failed to install the following Python CLI tools:"
		printf '  - %s\n' "${failed_tools[@]}"
		return 1
	fi

	success "Python CLI tools installed with uv!"
	info "To install Python libraries in a project, use:"
	info "  cd your-project && uv venv && uv pip install pandas numpy matplotlib"
	return 0
}

apt_install() {
	run_command "sudo apt update"
	run_command "sudo apt install -y ${apt_packages[*]}"
}

apt-wsl_install() {
	run_command "sudo apt update"
	run_command "sudo apt install -y ${wsl_packages[*]}"
}

rpm_install() {
	run_command "sudo dnf install --refresh -y ${rpm_packages[*]}"
	run_command "sudo dnf group install -y ${rpm_groups[*]}"
}

arch_install() {
	run_command "sudo pacman -Sy --needed --noconfirm ${arch_packages[*]}"
}

install_astronvim() {
	if [[ "$SKIP_ASTRONVIM" == true ]]; then
		info "Skipping AstroNvim installation (--skip-astronvim flag)."
		return 0
	fi

	if ! confirm_action "Would you like to install AstroNvim?"; then
		info "Skipping AstroNvim installation."
		return 0
	fi

	info "Starting the AstroNvim installer."

	# Back up existing Neovim configuration
	if [[ -d $HOME/.config/nvim ]]; then
		info "Backing up current NeoVim configuration to $HOME/.config/nvim.bak"
		run_command "mv '$HOME/.config/nvim' '$HOME/.config/nvim.bak'"
	fi

	# Clean existing NeoVim folders
	if [[ -d $HOME/.local/share/nvim ]]; then
		info "Backing up local NeoVim folders."
		run_command "mv '$HOME/.local/share/nvim' '$HOME/.local/share/nvim.bak'"
		run_command "mv '$HOME/.local/state/nvim' '$HOME/.local/state/nvim.bak'"
		run_command "mv '$HOME/.cache/nvim' '$HOME/.cache/nvim.bak'"
	fi

	run_command "git clone --depth 1 https://github.com/AstroNvim/template '$HOME/.config/nvim'"
	run_command "rm -rf '$HOME/.config/nvim/.git'"

	success "AstroNvim installed successfully."
	info "Please run NeoVim (nvim) after bootstrap finishes to complete the installation of AstroNvim."

	return 0
}

install_software() {
	info "Installing software with system package manager."
	"${PACKAGE_MANAGER}"_install
	return 0
}

install_neovim() {
	if [[ "$SKIP_NEOVIM" == true ]]; then
		info "Skipping Neovim installation (--skip-neovim flag)."
		return 0
	fi

	info "This script will attempt to install the latest stable version of Neovim using the appimage."
	info "This is only necessary if you need a recent version of NeoVim and your distro does not include it."

	if _exists nvim; then
		local nvim_version
		nvim_version="$(nvim -v | head -1 | cut -d"v" -f2)"
		info "Currently installed version of NeoVim: [$nvim_version]"
	else
		info "NeoVim does not appear to be installed."
	fi

	if ! confirm_action "Would you like to proceed with Neovim AppImage installation?"; then
		info "Skipping NeoVim Appimage installation."
		return 0
	fi

	local package_name="nvim-linux-x86_64.appimage"
	local download_link="https://github.com/neovim/neovim/releases/download/v0.11.3/$package_name"
	local install_dir="/opt/nvim"
	local install_path="$install_dir/nvim"

	# Create installation directory
	run_command "sudo mkdir -p '$install_dir'"

	# Download the latest Neovim AppImage
	run_command "wget -O /tmp/nvim.appimage '$download_link'"

	# Make the downloaded file executable
	run_command "chmod +x /tmp/nvim.appimage"

	# Move the AppImage to /opt/nvim/
	run_command "sudo mv /tmp/nvim.appimage '$install_path'"

	# Create symlink in /usr/local/bin for system-wide access
	run_command "sudo ln -sf '$install_path' /usr/local/bin/nvim"

	success "NeoVim AppImage installed successfully to $install_path"
	info "Symlinked to /usr/local/bin/nvim for system-wide access"
	return 0
}

set_zsh() {
	local shell
	if ! _exists zsh; then
		warn "ZSH not found! Other shells are not currently supported"
		return 1
	fi

	shell="$(_user_default_shell)"
	if [[ "${shell,,}" != "zsh" ]]; then
		info "Default shell will be changed to ZSH."

		if confirm_action "Are you sure you want to change the default shell to ZSH?" "y"; then
			run_command "chsh -s '$(which zsh)'"
		fi
	else
		info "ZSH is already the default shell."
	fi

	return 0
}

install_external_required() {
	if [[ "$SKIP_RUST" == false ]]; then
		track_task "Rust Installation" install_rustup
		track_task "Cargo Packages" cargo_install
	fi
	# Install uv for Python package management
	track_task "uv Installation" install_uv
}

install_external_optional() {
	if [[ "$SKIP_NEOVIM" == false ]]; then
		track_task "Neovim Installation" install_neovim
	fi
	if [[ "$SKIP_FNM" == false ]]; then
		track_task "fnm Installation" install_fnm
		# Install npm packages after fnm is set up
		track_task "NPM Packages" npm_install
	fi
	if [[ "$SKIP_GO" == false ]]; then
		track_task "Go Installation" install_go
	fi
	if [[ "$SKIP_GITUI" == false ]]; then
		track_task "GitUI Installation" install_gitui
	fi
	if [[ "$SKIP_ASTRONVIM" == false ]]; then
		track_task "AstroNvim Installation" install_astronvim
	fi

	# Install Python CLI tools via uv
	track_task "Python CLI Tools (uv)" uv_install
}

install_external() {
	info "Installing external software."
	install_external_required
	install_external_optional
}

on_finish() {
	info "=============================================="
	info "Bootstrap installation completed!"
	info ""

	# Auto-source zshrc if zsh is installed and this is a zsh session
	if _exists zsh && [[ -n "${ZSH_VERSION:-}" ]] && [[ -f "$HOME/.zshrc" ]]; then
		info "Reloading shell configuration..."
		if [[ "$DRY_RUN" == false ]]; then
			source "$HOME/.zshrc"
			success "Shell configuration reloaded!"
		else
			info "[DRY RUN] Would reload shell configuration"
		fi
		info ""
	fi

	info "Next steps:"
	info "1. If not using zsh: Restart your terminal or run 'exec zsh'"
	info "2. If fnm was installed, run 'node --version' to verify"
	info "3. If AstroNvim was installed, run 'nvim' to complete setup"
	info "4. Customize your configuration in ~/.zshlocal"
	info ""
	success "Happy coding! ðŸš€"
}

main() {
	on_start
	track_task "System Packages" install_software
	install_external
	track_task "Shell Setup" set_zsh
	show_summary
	on_finish
}

main "$@"

# vim: ft=sh
